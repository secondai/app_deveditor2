{
  "type": "react_component:0.0.1:local:98912hd89",
  "name": "ListRemoteComponent",
  "data": {
    "version": "1",
    "note": "/dev left side",
    "internalId": "ListRemoteComponent",
    "code": "(()=>{\n  \n  let __parsedFiles = {};\n  function jsonParse(key, contents){\n    if(__parsedFiles[key]){\n      return __parsedFiles[key]\n    }\n  \n    __parsedFiles[key] = JSON.parse(contents);\n    return __parsedFiles[key];\n  \n  }\n  \n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      class ErrorComponent extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        \n        render(){\n          return (\n            <div>\n              [ErrorRenderer]\n            </div>\n          )\n        }\n      }\n      \n      class ListComponent extends React.Component {\n        constructor(props){\n          super(props);\n          this.state = {\n            nodes: [],\n            text: '',\n            pastable: false,\n            pasteText: ''\n          }\n        }\n        \n        componentDidMount(){\n          this.fetchRemoteNodes();\n          \n          \n          universe.EE.on('nodes-modified', this.fetchRemoteNodes);\n        \n        }\n        componentWillUnmount(){\n          universe.EE.removeListener('nodes-modified', this.fetchRemoteNodes);\n        }\n        \n        @autobind\n        fetchRemoteNodes(){\n          \n          // \n          return new Promise(async (resolve,reject)=>{\n              \n            try {\n              \n              this.setState({\n                fetchingRemote: true\n              })\n              \n              // let ExternalIdentityNodes = await universe.searchMemory({\n              //   filter: {\n              //     sqlFilter: {\n              //       type: 'external_identity:0.0.1:local:8982f982j92',\n              //       data: {\n              //         commonName: 'main'\n              //       }\n              //     }\n              //   }\n              // });\n              // let ExternalIdentityNode = ExternalIdentityNodes[0];\n              \n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                            dataForAction: {\n                              type: 'string:...',\n                              data: this.props.state.OwnerSecondExternalIdentityNode.data.token\n                            }\n                          },\n                          {\n                            matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n                            dataForAction: {\n                              type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                              data: {\n                                responseType: 'cjson',\n                                dataFilter: {\n                                  nodeId: null\n                                },\n                                matchFunctionNode: {\n                                  // query here!\n                                  // action_pointer:0.0.1:local:238972ncr\n                                  type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n                                  data: {\n                                    code: `(()=>{\n                                      // Action \n                                      // - childNode common_type:0.0.1:local:298fh29h2323f == \"action\" \n                                      \n                                      let inputNode = INPUT.data.inputNode;\n                                      \n                                      if(inputNode.nodeId){\n                                        return false;\n                                      }\n                                      \n                                      // if(inputNode.type != 'learning_pointer:0.0.1:local:3289h3238h92'){\n                                      //   return null;\n                                      // }\n                                      \n                                      // if(inputNode.data.learn != 'browser_developer'){\n                                      //   return null;\n                                      // }\n                                      \n                                      // // strip childnodes\n                                      // // delete inputNode.nodes; \n                                      // // delete inputNode.parent;\n                                      // delete inputNode.data;\n              \n                                      return inputNode;\n                                      \n                                    })()`\n                                  }\n                                },\n                                // expected/allowed schemas for return \n                                // outputSchemas: [\n                                //   'query_result:0.0.1:local:32490usfj23o23f',\n                                //   'internal_error_output:0.0.1:local:32948x2u3cno2c'\n                                // ]\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n              let nodes = response.data.actionResponses[1].data;\n              \n              if(typeof nodes == 'string'){\n                console.log('cjson returned for nodes');\n                nodes = universe.cJSON.parse(nodes);\n              } else {\n                console.log('NOT CJSON!');\n              }\n              \n              console.log('Nodes:', nodes);\n              \n              // let componentNode = await universe.runInVM(result[0],{});\n              this.setState({\n                nodes: nodes,\n                fetchingRemote: false,\n                selectedNodes: []\n              })\n              \n              // Update the \"editingNode\" too \n              // - ideally wouldn't reload the window, but oh well? \n              let editingNode = this.props.state.editingNode;\n              if(editingNode){\n                \n                function checkChildren(nodes){\n                  for(let node of nodes){\n                    if(node._id == editingNode._id){\n                      editingNode = node;\n                    }\n                    if(node.nodes){\n                      checkChildren(node.nodes);\n                    }\n                  }\n                }\n                checkChildren(nodes);\n              }\n              \n              console.log('EditingNode to update:', editingNode);\n              // this.props.setState({\n              //   editingNode\n              // });\n              \n              \n            } catch(err){\n              console.error('Failed getting local nodes');\n              \n              this.setState({\n                fetchingRemote: false\n              })\n              \n            }\n            \n          });\n          \n          \n          // this.setState({\n          //   value: 5\n          // });\n          \n          // WINDOW.alert(10);\n          // let x = WINDOW.prompt('what','');\n          // this.setState({\n          //   value: parseInt(x,10)\n          // })\n          \n          \n          // let IdentityNode = null;\n          // let identities = await universe.searchMemory({\n          //   filter: {\n          //     sqlFilter: {\n          //       type: 'remote_datasource:0.0.1:local:298f3h92hf9s8dhf23f'\n          //     },\n          //     // function for returning data from the Node, after filtering a bit \n          //     // - includes both the Node, and Nodes with nodeId (pointers) \n          //     filterNodes: tmpNodes=>{\n          //       // this runs isolated, outside of the above context? (not sure) \n          //       return new Promise((resolve, reject)=>{\n          //         resolve(tmpNodes);\n          //       });\n          //     },\n          //   }\n          // });\n        }\n      \n        @autobind\n        handleNewNode(){\n      \n          return new Promise(async (resolve,reject)=>{\n      \n            let type;\n            type = WINDOW.prompt('Type','');\n            if(!type){\n              return false;\n            }\n            \n            type = type.trim();\n            \n            let name = WINDOW.prompt('Name',universe.uuidv4());\n            if(!name){\n              return false;\n            }\n            \n            // todo: get and validate the type's schema. use schema for default data\n            \n            let newNode = {\n              // nodeId: node._id,\n              name,\n              type,\n              data: null\n            }\n      \n            console.log('newNode:', newNode);\n      \n            let savedNode = await this.forceNewNode(newNode, {skipExistingLearnedNodeId: true});\n            \n            console.log('Saved Node', savedNode);\n      \n            try {\n              universe.EE.emit('nodes-modified', '');\n            }catch(err){\n              console.error(err);\n            }\n            \n      \n            // window.location = '/node/' + savedNode._id;\n      \n          });\n      \n        }\n        \n        @autobind\n        async handleAddMany(){\n          // Adding a whole bunch, for testing \n          \n          if(!WINDOW.confirm('Save 20 nodes?')){\n            return false;\n          }\n          \n          for(let i in universe.lodash.range(0,20)){\n            console.log('Saving new node');\n            let nodeToSave = {\n              type: 'text_note:0.0.1:local:8290j2981',\n              data: {\n                text: 'test textnote ' + (new Date()).getTime()\n              },\n              active: true,\n              createdAt: (new Date()).getTime()\n            }\n            \n            await this.forceNewNode(nodeToSave, {skipExistingLearnedNodeId:true}, true);\n            \n          }\n          \n          try {\n            universe.EE.emit('nodes-modified', '');\n          }catch(err){\n            console.error(err);\n          }\n          \n        }\n        \n        @autobind\n        makeSaveRequest(nodeToSave, opts, skipEvent){\n          return new Promise(async (resolve, reject) => {\n            \n            this.setState({\n              saving: true\n            })\n            \n            opts = opts || {};\n            \n            // Make request to save Node on remote \n            try {\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                            dataForAction: {\n                              type: 'string:...',\n                              data: this.props.state.OwnerSecondExternalIdentityNode.data.token\n                            }\n                          },\n                          {\n                            matchActionType: 'update_node:0.0.2:local:392821982y3',\n                            dataForAction: {\n                              type: 'update_node_data:0.0.2:local:123445',\n                              data: {\n                                optionsNode: {\n                                  type: 'options_generic:0.0.1:local:289f3j29832',\n                                  data: opts || {}\n                                },\n                                dataNode: nodeToSave\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              console.log('Update response:', response);\n              \n              if(skipEvent !== true){\n                try {\n                  universe.EE.emit('nodes-modified', '');\n                }catch(err){\n                  console.error(err);\n                }\n              }\n              \n              this.setState({\n                saving: false\n              })\n              \n              return resolve({\n                type: 'node:...',\n                data: response.data.actionResponses[1]\n              });\n              \n            } catch(err){\n              console.error('Failed getting local nodes');\n              \n              alert('Failed');\n              \n              this.setState({\n                saving: false\n              })\n              \n              return reject();\n              \n            }\n            \n          })\n        }\n        \n        @autobind\n        makeRebuildMemoryRequest(){\n          return new Promise(async (resolve, reject) => {\n            \n            try {\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                            dataForAction: {\n                              type: 'string:...',\n                              data: this.props.state.OwnerSecondExternalIdentityNode.data.token\n                            }\n                          },\n                          {\n                            matchActionType: 'rebuild_memory:Qmdsf892hf98h23',\n                            dataForAction: {\n                              type: 'rebuild_memory:0.0.2:local:123445',\n                              data: {\n                                skipWaitForResolution: false\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              \n              return resolve({\n                type: 'boolean:...',\n                data: true\n              });\n              \n            } catch(err){\n              console.error('Failed rebuildMemory');\n              \n              alert('Failed rebuildMemory');\n              \n              return reject();\n              \n            }\n            \n          })\n        }\n        \n        @autobind\n        forceNewNode(nodeToSave, opts, skipEvent){\n          return new Promise(async (resolve, reject) => {\n            \n            console.log('NewNode:', nodeToSave);\n                \n            // return resolve({\n            //   saveNewNode: nodeToSave\n            // });\n            \n            \n            // Make request to save Node on remote \n            try {\n              \n              // let ExternalIdentityNodes = await universe.searchMemory({\n              //   filter: {\n              //     sqlFilter: {\n              //       type: 'external_identity:0.0.1:local:8982f982j92',\n              //       data: {\n              //         commonName: 'main'\n              //       }\n              //     }\n              //   }\n              // });\n              // let ExternalIdentityNode = ExternalIdentityNodes[0];\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                            dataForAction: {\n                              type: 'string:...',\n                              data: this.props.state.OwnerSecondExternalIdentityNode.data.token\n                            }\n                          },\n                          {\n                            matchActionType: 'forced_learn_node:0.0.1:local:34907234987sf23',\n                            dataForAction: {\n                              type: 'forced_learn_node:0.0.1:local:34907234987sf23',\n                              data: {\n                                optionsNode: {\n                                  type: 'options_generic:0.0.1:local:289f3j29832',\n                                  data: opts || {}\n                                },\n                                dataNode: nodeToSave\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              console.log('NewNode response:', response);\n              \n              // get the new node \n              let savedNode = response.data.actionResponses[1];\n              \n              // console.log('Saved Node:', savedNode);\n              \n              if(skipEvent !== true){\n                try {\n                  universe.EE.emit('nodes-modified', '');\n                }catch(err){\n                  console.error(err);\n                }\n              }\n              \n              return resolve(savedNode);\n              \n              // this.setState({\n              //   saving: false\n              // })\n              \n            } catch(err){\n              console.error('Failed getting local nodes');\n              \n              // alert('Failed');\n              \n              // this.setState({\n              //   saving: false\n              // })\n              \n            }\n            \n          })\n        }\n        \n        @autobind\n        async handleCreateInvite(){\n          \n          let inviteCode = universe.uuidv4();\n          \n          let name = WINDOW.prompt('Note for invite code?', '');\n          if(!name){\n            return false;\n          }\n          \n          let network = WINDOW.prompt('Network (public or test)', 'test');\n          if(network != 'public' && network != 'test'){\n            return false;\n          }\n          \n          inviteCode = WINDOW.prompt('Invite Code (should be unique!)', inviteCode);\n          if(!inviteCode){\n            return false;\n          }\n          \n          // TODO: \n          // - uniqueness check/constraint \n        \n          let newNode = {\n            name: universe.uuidv4(),\n            nodeId: null,\n            type: 'account_invite:Qm2934872344232324', // invite\n            data: {\n              name,\n              inviteCode,\n              network,\n              sourcePublicKey: null,\n              accepted: false,\n              uploadBytes: 0\n            }\n          }\n          \n          console.log('new invite node:', newNode);\n    \n          let savedNode = await this.forceNewNode(newNode);\n            \n          WINDOW.prompt('Invite Created!', inviteCode);\n            \n        }\n      \n        @autobind\n        handleDelete(){\n      \n          return new Promise(async (resolve,reject)=>{\n            \n            let selectedNodes = this.props.state.selectedNodes || [];\n            \n            if(!selectedNodes.length){\n              WINDOW.alert('Select nodes using SHIFT key and clicking');\n              return false;\n            }\n      \n            // Create this new one, then iterate down the tree of kids \n            // - if this one has a nodeId, ask if we want to keep it? \n            let confirmed = WINDOW.prompt('Delete for sure?','y');\n            if(confirmed != 'y'){\n              return false;\n            }\n            \n            this.setState({\n              fetchingRemote: true\n            })\n            \n            for(let node of selectedNodes){\n                \n              // let node = JSON.parse(JSON.stringify(tmpNode));\n              console.log('Node to delete:', node);\n              node.active = false;\n              let deleted = await this.makeSaveRequest({\n                _id: node._id,\n                active: false\n              }, {\n                skipWaitForResolution: true, \n                skipRebuild: true\n              }, true);\n              \n              const deleteChildNodes = (childNodes) => {\n                return new Promise(async (resolve, reject)=>{\n                  \n                  for(let tmpNode of childNodes){\n                    console.log('ChildNode to delete:', tmpNode);\n                    // let deletedChildNode = await this.makeDelete(tmpNode);\n                    tmpNode.active = false;\n                    let deletedChildNode = await this.makeSaveRequest({\n                      _id: tmpNode._id,\n                      active: false\n                    }, {\n                      skipWaitForResolution: true, \n                      skipRebuild: true\n                    }, true);\n        \n                    if(tmpNode.nodes && tmpNode.nodes.length){\n                      await deleteChildNodes(tmpNode.nodes);\n                    }\n                  }\n                  resolve();\n        \n                });\n              }\n        \n              if(node.nodes){\n                await deleteChildNodes(node.nodes);\n              }\n            }\n      \n            console.log('rebuilding memory on remote, after bulk updates');\n            await this.makeRebuildMemoryRequest();\n            \n            this.setState({\n              fetchingRemote: false\n            });\n        \n            console.log('Done Deleting (and children)');\n          \n            try {\n              universe.EE.emit('nodes-modified', '');\n            }catch(err){\n              console.error(err);\n            }\n            \n            this.props.setState({\n              editingNode: null\n            })\n            \n            // Update nodes \n            this.fetchRemoteNodes();\n            \n            // window.location = '/node';\n      \n          });\n      \n        }\n        \n        @autobind\n        handleClickNode(node, e){\n          \n          if(e.shiftKey){\n            // select multiple \n            let selectedNodes = this.props.state.selectedNodes || [];\n            let idx = selectedNodes.indexOf(node);\n            if(idx > -1){\n              selectedNodes.splice(idx,1);\n            } else {\n              selectedNodes.push(node);\n            }\n            \n            this.props.setState({\n              editingNode: null,\n              selectedNodes\n            })\n            \n            WINDOW.document.getSelection().removeAllRanges();\n            \n          } else {\n            \n            // build editingNode (without circular references) \n            function buildNode(tmpNode){\n              let tmpReturnNode = {\n                _id: tmpNode._id,\n                nodeId: tmpNode.nodeId,\n                name: tmpNode.name,\n                type: tmpNode.type,\n                data: tmpNode.data,\n                nodes: [],\n                createdAt: tmpNode.createdAt,\n                updatedAt: tmpNode.updatedAt,\n              }\n              if(tmpNode.nodes){\n                for(let iTmpNode of tmpNode.nodes){\n                  tmpReturnNode.nodes.push(buildNode(iTmpNode));\n                }\n              }\n              return tmpReturnNode;\n            }\n            \n            let editingNode = buildNode(node);\n            \n            this.props.setState({\n              editingNode,\n              selectedNodes: []\n            })\n          }\n        }\n        \n        @autobind\n        handleImportZip(){\n          \n          return new Promise(async (resolve,reject)=>{\n            \n            let url = WINDOW.prompt('ZIP URL (github urls parsed automatically)',''); \n            if(!url){\n              return false;\n            }\n            \n        \n            // converts startup git url into username/password \n            // - eventually allow links to be pasted, parse accordingly \n        \n            // parse github links and re-organize to fit .zip model \n        \n            this.setState({\n              saving: true\n            });\n            \n            let gh = universe.parseGitHubUrl(url);\n            if(gh.owner && \n              gh.name && \n              gh.repo && \n              gh.branch){\n              url = `https://github.com/${gh.repo}/archive/${gh.branch}.zip`;\n            }\n        \n            // cannot simply follow github zipball/tarball links :( \n            universe.fetch(`https://cors-anywhere.herokuapp.com/${url}`,{\n              // mode: 'no-cors' \n            })\n            .then(response=>{\n              // console.log('Response:', response);\n              return response.arrayBuffer();\n            })\n            .then(universe.JSZip.loadAsync)\n            .then(async (zip)=>{\n              \n              console.log('loaded zip data!', zip);\n      \n              // ZIP is valid! \n              let files = zip.files;\n      \n              function readFilePath(p){\n                return new Promise(async (resolve,reject)=>{\n                  console.log('path:', p);\n                  let r = await files[p].async('text')\n                  resolve(r);\n                });\n              }\n      \n              // load all the files \n              let allFiles = {};\n              for(let filepath of Object.keys(files)){\n                let file = files[filepath];\n                if(file.dir){\n      \n                } else {\n                  // console.log('filepath:', filepath);\n                  let contents = await readFilePath(filepath);\n                  // console.log('contents:', contents);\n                  let normalizedPath = filepath.split('/').splice(1).join('/');\n                  allFiles[normalizedPath] = contents;\n                }\n              }\n      \n              console.log('allFiles from Zip:', allFiles);\n              \n              // function addChildren(id){\n              //   return new Promise(async (resolve,reject)=>{\n            \n              //     let nodes = [];\n              //       for(let filepath of Object.keys(allFiles)){\n              //         console.log('addChildren:', filepath);\n              //         let contents = allFiles[filepath];\n              //         if(filepath.indexOf('nodes/') !== 0){\n              //           // console.log('NOT NODE:', filepath);\n              //           continue;\n              //         }\n        \n              //         let parsed = jsonParse(filepath, contents);\n              //         if(parsed.nodeId == id){\n              //           // console.log('Matches ID:', parsed.nodeId, id);\n              //           let children = await addChildren(parsed._id);\n              //           parsed.nodes = children;\n              //           nodes.push(parsed);\n              //         } else {\n              //         // console.log('No Kids:', id, parsed.nodeId);\n              //       }\n      \n              //     }\n      \n              //     resolve(nodes);\n      \n              //   });\n              // }\n              \n              function addChildren(path){\n                return new Promise(async (resolve,reject)=>{\n                \n                  let nodes = [];\n                  try {\n                      \n                    for(let filepath of Object.keys(allFiles)){\n                      let contents = allFiles[filepath];\n                      if(filepath.indexOf(path) !== 0){\n                        // console.log('NOT NODE:', filepath);\n                        continue;\n                      }\n                      let pathDepth = path.split('/').length;\n                      let filepathDepth = filepath.split('/').length;\n                      if(pathDepth == filepathDepth){\n                        // xyz.json at correct depth\n                        \n                        let parsed = jsonParse(filepath, contents);\n                        // if(parsed.nodeId == id){\n                          // console.log('Matches ID:', parsed.nodeId, id);\n                          let children = await addChildren(filepath.slice(0, filepath.length - 5) + '/'); // remove '.json'\n                          parsed.nodes = children;\n                          nodes.push(parsed);\n                        // } else {\n                        //   // console.log('No Kids:', id, parsed.nodeId);\n                        // }\n                      }\n        \n        \n                    }\n                  }catch(err){\n                    console.error(err);\n                  }\n    \n                  resolve(nodes);\n                  \n                });\n              }\n      \n              // re-organize child nodes \n              let ZipNodes;\n              try {\n                // ZipNodes = await addChildren(null); // start at root, adds children recursively\n                ZipNodes = await addChildren('nodes/'); // start at root, adds children recursively \n              }catch(err){\n                console.error('Failed zipnodes', err);\n                WINDOW.alert('Failed fetching zip nodes');\n              }\n        \n              console.log('ZipNodes:', ZipNodes);\n              \n              // let secondJson = JSON.parse(allFiles['second.json']);\n              // let basicKey = secondJson.name; \n              \n              \n              for(let node of ZipNodes){\n              \n                // iterate\n                // - save this one, then start saving down tree\n                let newNode = {\n                  name: node.name,\n                  nodeId: null, // saving to root-level!\n                  type: node.type,\n                  data: node.data,\n                }\n          \n                console.log('newNode:', newNode);\n          \n                let savedNode = await this.forceNewNode(newNode, {skipWaitForResolution: false, skipRebuild: false}, true);\n                \n                console.log('Saved Node');\n              \n                const saveChildNodes = (nodeId, childNodes) => {\n                  return new Promise(async (resolve, reject)=>{\n          \n                    console.log('Saving children');\n                    \n                    for(let tmpNode of childNodes){\n                      let newChildNode = {\n                        name: tmpNode.name,\n                        nodeId,\n                        type: tmpNode.type,\n                        data: tmpNode.data,\n                      }\n                      let savedChildNode = await this.forceNewNode(newChildNode, {skipWaitForResolution: false, skipRebuild: false}, true);\n          \n                      if(tmpNode.nodes && tmpNode.nodes.length){\n          \n                        await saveChildNodes(savedChildNode.data._id, tmpNode.nodes);\n          \n                      }\n                    }\n                    resolve();\n                  });\n                }\n          \n                await saveChildNodes(savedNode.data._id, node.nodes);\n                \n              }\n              \n              console.log('rebuilding memory on remote, after bulk updates');\n              // await this.makeRebuildMemoryRequest();\n              \n              console.log('Done Adding via Zip');\n          \n              this.setState({\n                saving: false\n              });\n              \n              try {\n                universe.EE.emit('nodes-modified', '');\n              }catch(err){\n                console.error(err);\n              }\n      \n      \n            })\n\n            \n          });\n          \n        }\n        \n        @autobind\n        handleInsertNodePaste(){\n          \n          return new Promise(async (resolve,reject)=>{\n      \n            let nodeText = this.state.pasteText; //WINDOW.prompt('Node JSON String','');\n            if(!nodeText){\n              return false;\n            }\n            \n            let node = JSON.parse(nodeText);\n            console.log('Node input:', node);\n            \n            // Create this new one, then iterate down the tree of kids \n            // - if this one has a nodeId, ask if we want to keep it? \n            let confirmed = WINDOW.prompt('Save node ('+node.type+') and children for sure?','y');\n            if(confirmed != 'y'){\n              return false;\n            }\n            \n            // iterate\n            // - save this one, then start saving down tree\n            let newNode = {\n              name: node.name || universe.uuidv4(),\n              nodeId: null, \n              type: node.type,\n              data: node.data,\n            }\n      \n            console.log('newNode:', newNode);\n      \n            let savedNode = await this.forceNewNode(newNode, {skipExistingLearnedNodeId: true});\n            \n            console.log('Saved Node');\n          \n            const saveChildNodes = (nodeId, childNodes) => {\n              return new Promise(async (resolve, reject)=>{\n      \n                console.log('Saving children');\n                \n                for(let tmpNode of childNodes){\n                  let newChildNode = {\n                    name: tmpNode.name || universe.uuidv4(),\n                    nodeId,\n                    type: tmpNode.type,\n                    data: tmpNode.data,\n                  }\n                  let savedChildNode = await this.forceNewNode(newChildNode, {skipExistingLearnedNodeId: true});\n      \n                  if(tmpNode.nodes && tmpNode.nodes.length){\n      \n                    await saveChildNodes(savedChildNode.data._id, tmpNode.nodes);\n      \n                  }\n                }\n                resolve();\n              });\n            }\n      \n            await saveChildNodes(savedNode.data._id, node.nodes);\n            \n            console.log('Done Adding via Paste');\n      \n            try {\n              universe.EE.emit('nodes-modified', '');\n            }catch(err){\n              console.error(err);\n            }\n            \n          });\n        }\n        \n        @autobind\n        handleNewId(){\n          let uuid = universe.uuidv4();\n          universe.copy(uuid);\n          console.log('Copied to clipboard');\n        }\n        \n        @autobind\n        renderNodes(nodes, parentInFilter){\n          \n          let filters = this.state.text.split('>');\n          // reverse filters when checking\n          filters.reverse();\n          \n          nodes = universe.lodash.sortBy(nodes, 'updatedAt');\n          // console.log('Nodes',nodes);\n          \n          return (\n            <div className=\"\">\n              {\n                nodes.map(node=>{\n                          \n                  // include this node if it, or of of it's children, matches\n                  // - highlight if a match \n                \n                  const nodeMatchFunc = (node) => {\n                    // returns true if this node is a \"final match\" \n                    \n                    function checkNodeFilterMatch(tmpCheckNode, filter){\n                      let nodeFilterMatch;\n                      if(tmpCheckNode._id && tmpCheckNode._id.toString().includes(filter)){\n                        nodeFilterMatch = true;\n                      }\n                      if(tmpCheckNode.type && tmpCheckNode.type.includes(filter)){\n                        nodeFilterMatch = true;\n                      }\n                      if(tmpCheckNode.name && tmpCheckNode.name.includes(filter)){\n                        nodeFilterMatch = true;\n                      }\n                      if(tmpCheckNode.data && JSON.stringify(tmpCheckNode.data).includes(filter)){\n                        nodeFilterMatch = true;\n                      }\n                      // type (t:)\n                      if(filter.substring(0,2) == 't:' && tmpCheckNode.type){\n                        let tmpFilter = filter.split('t:')[1];\n                        if(tmpCheckNode.type && tmpCheckNode.type.includes(tmpFilter)){\n                          nodeFilterMatch = true;\n                        }\n                      }\n                      // name (n:)\n                      if(filter.substring(0,2) == 'n:' && tmpCheckNode.name){\n                        let tmpFilter = filter.split('n:')[1];\n                        if(tmpCheckNode.name && tmpCheckNode.name.includes(tmpFilter)){\n                          nodeFilterMatch = true;\n                        }\n                      }\n                      // data (d:) \n                      if(filter.substring(0,2) == 'd:'){\n                        let tmpFilter = filter.split('d:')[1];\n                        if(tmpCheckNode.data && JSON.stringify(tmpCheckNode.data).includes(tmpFilter)){\n                          nodeFilterMatch = true;\n                        }\n                      }\n                      // sibling type (st:) \n                      if(filter.substring(0,3) == 'st:' ){\n                        let tmpFilter = filter.split('st:')[1];\n                        try {\n                          let findSiblingMatch = tmpCheckNode.parent.nodes.find(n=>{\n                            if(n.type && n.type.includes(tmpFilter)){\n                              return true;\n                            }\n                          });\n                          if(findSiblingMatch){\n                            nodeFilterMatch = true;\n                          }\n                        }catch(err){\n                          // console.error(err);\n                        }\n                      }\n                      // dirtyJson (obj matcher)\n                      if(filter.substring(0,1) == '{' && filter.substring(filter.length - 1) == '}'){\n                        try {\n                          let parsedJson = universe.dirtyJSON.parse(filter);\n                          if(universe.lodash.query([tmpCheckNode.data],parsedJson).length){\n                            nodeFilterMatch = true;\n                          }\n                        }catch(err){\n                          // console.error(err);\n                        }\n                      }\n                      return nodeFilterMatch;\n                    }\n                    \n                    // iterate through filters (TODO) \n                    // - find next parent in chain that matches \n                    let filtersClone = filters.concat();\n                    let lastFilter = filtersClone.shift().trim();\n                    \n                    let filtersToPass = lastFilter.split('&');\n                    \n                    let passedAll = true;\n                    for(let ftp of filtersToPass){\n                      \n                      ftp = ftp.trim();\n                      \n                      if(checkNodeFilterMatch(node, ftp)){\n                        // matches the last check, see if parents need to be checked \n                        if(filtersClone.length){\n                          // has a parent chain to check\n                          console.log('has parent chain to check!!');\n                          // return true;\n                        } else {\n                          // no other filters, dont need to check parent chain \n                          // return true;\n                        }\n                      } else {\n                        passedAll = false;\n                      }\n                    }\n                    \n                    if(passedAll){\n                      return true;\n                    }\n                    \n                    return null;\n                    \n                  }\n                  \n                  const childMatchFunc = (nodes) => {\n                    for(let tmpNode of nodes){\n                      if(nodeMatchFunc(tmpNode)){\n                        return true;\n                      }\n                      if(childMatchFunc(tmpNode.nodes)){\n                        return true;\n                      }\n                    }\n                    return false;\n                  }\n                  \n                  let hasFilter = (filters.length && filters[0].length) ? true:false;\n                  let nodeMatch;\n                  let childMatch;\n                  if(hasFilter){\n                    \n                    nodeMatch = nodeMatchFunc(node);\n                    childMatch = childMatchFunc(node.nodes || []);\n                    \n                    // check children \n                    // - lots of recursion here, probably should memoize \n                    \n                    \n                    // // filter by \"text\" if set \n                    // nodes = nodes.filter(node=>{\n                    //   return true;\n                    // })\n                  }\n                  \n                  if(hasFilter && !nodeMatch && !childMatch && !parentInFilter){\n                    return undefined; // skip\n                  }\n                  \n                  let tooltip = null;\n                  // return a different tooltip depending on the type\n                  let nodeTypeFirst = node.type ? node.type.split(':')[0]:null;\n                  try {\n                    switch(nodeTypeFirst){\n                      case 'react_component':\n                        tooltip = node.data.internalId;\n                        break;\n                        \n                      case 'parent_of_nodes_to_learn':\n                        tooltip = node.data.learn;\n                        break;\n                        \n                      case 'text_tag':\n                        tooltip = node.data.text;\n                        break;\n                        \n                      case 'capability':\n                        tooltip = node.data.key;\n                        break;\n                        \n                      case 'code':\n                        tooltip = node.data.note;\n                        break;\n                        \n                      case 'external_identity':\n                        tooltip = node.data.commonName || '(no commonName)';\n                        break;\n                        \n                      case 'external_identity_connect_method':\n                        tooltip = node.data.connection;\n                        break;\n                        \n                      case 'folder':\n                        tooltip = node.data.key;\n                        break;\n                        \n                      case 'node_repo_on_github':\n                        tooltip = node.data.repo;\n                        break;\n                        \n                      case 'app_base':\n                        tooltip = [node.data.name, node.data.appId].join(' - ');\n                        break;\n                        \n                      case 'platform_nodes':\n                        tooltip = node.data.platform;\n                        break;\n                        \n                      default:\n                        break;\n                    }\n                  }catch(err){\n                  }\n                  \n                  let rowStyle = {whiteSpace:'nowrap'};\n                  if(this.props.state.editingNode && this.props.state.editingNode._id == node._id){\n                    rowStyle.fontWeight = 'bold';\n                  }\n                  \n                  if(this.props.state.selectedNodes && this.props.state.selectedNodes.find(n=>{return n._id == node._id})){\n                    rowStyle.background = 'red';\n                  }\n                  \n                  return (\n                    <div key={node._id}>\n                      <div onClick={e=>this.handleClickNode(node, e)} style={{cursor:'pointer', color: nodeMatch ? 'blue':'inherit'}}>\n                    \n                          <div className=\"hover-item tooltip-holder\">\n                            <div className=\"tooltip-trigger\">\n                              <span style={rowStyle}>\n                                {node.name} <span style={{opacity:\"0.7\"}}>({node.type})</span>\n                              </span>\n                            </div>\n                            {\n                              !tooltip ? '':\n                              <div className=\"tooltip\">\n                                {tooltip}\n                              </div>\n                            }\n                          </div>\n                          \n                      </div>\n                      {\n                        !(node.nodes && node.nodes.length) ? '':\n                        <div style={{paddingLeft:'8px'}}>\n                          {this.renderNodes(node.nodes, parentInFilter || nodeMatch)}\n                        </div>\n                      }\n                    </div>\n                  )\n                })\n              }\n            </div>\n          )\n        }\n        \n        render(){\n          \n          let nodes = this.state.nodes;\n          \n          // load actions from remote!\n          // - want to have some default actions that are easy to call/trigger \n          // - simple way of calling a Capability? \n          let actions = [];\n          \n          return (\n            <div className=\"\" style={{position:'relative'}}>\n              \n              <div style={{position:'sticky', top: '0px', borderBottom:'1px solid #ccc', background: '#eee', zIndex:'1', width:'100%'}}>\n                \n                {\n                  !this.state.pastable ? '':\n                  <div>\n                    <textarea className=\"textarea\" value={this.state.pasteText} onChange={e=>this.setState({pasteText:e.target.value})} />\n                    <button className=\"button is-primary\" onClick={this.handleInsertNodePaste}>Save</button>\n                    <button className=\"button is-pulled-right\" onClick={e=>this.setState({pastable:false})}>cancel</button>\n                  </div>\n                }\n                \n                <strong>\n                  Second Nodes\n                  \n                  &nbsp;\n                  \n                  <button className={\"button is-small \" + (this.state.fetchingRemote ? 'is-loading':'')} onClick={this.fetchRemoteNodes}>\n                    <span className=\"icon is-small\">\n                      <i className=\"fas fa-sync\"></i>\n                    </span>\n                  </button>\n                  \n                  <div className=\"dropdown is-hoverable is-right is-pulled-right\">\n                    <div className=\"dropdown-trigger\">\n                      <button className=\"button is-small\">\n                        <span className=\"icon is-small\">\n                          <i className=\"fa fa-angle-down\"></i>\n                        </span>\n                      </button>\n                    </div>\n                    <div className=\"dropdown-menu\">\n                      <div className=\"dropdown-content\">\n                      \n                        <a className=\"dropdown-item\" onClick={this.handleNewId}>\n                          Copy New UUID to Clipboard\n                        </a>\n                        \n                        <a className=\"dropdown-item\" onClick={this.handleNewNode}>\n                          New Node by Type\n                        </a>\n                        \n                        <a className=\"dropdown-item\" onClick={e=>this.setState({pastable:true})}>\n                          Insert Node By Paste\n                        </a>\n                      \n                        <a className=\"dropdown-item\" onClick={this.handleImportZip}>\n                          Import Bundle (.Zip, or GitHub) \n                        </a>\n                        \n                        <a className=\"dropdown-item\" onClick={this.handleEncryptString}>\n                          Encrypt String\n                        </a>\n                        \n                        <a className=\"dropdown-item\" onClick={this.handleCreateInvite}>\n                          Create Invite\n                        </a>\n                        \n                        <a className=\"dropdown-item\" onClick={this.handleDelete}>\n                          Delete \n                        </a>\n                        \n                        \n                        <div className=\"dropdown-divider\"></div>\n                        \n                        <a className=\"dropdown-item\" onClick={this.handleAddMany}>\n                          Insert Many for Test\n                        </a>\n                        \n                      </div>\n                    </div>\n                  </div>\n                  \n                </strong>\n                \n                \n                <div>\n                  <input className=\"input\" value={this.state.text} onChange={e=>this.setState({text:e.target.value})} placeholder=\"Filter on type/name/data\" />\n                </div>\n                \n              </div>\n              \n              <div style={{position:'relative'}}>\n                {this.renderNodes(nodes)}\n              </div>\n              \n            </div>\n          )\n        }\n      }\n      \n      ListComponent = universe.ReactGlobalState(ListComponent);\n      \n      resolve({\n        type: 'react_component:0.0.1:local:98912hd89',\n        data: ListComponent\n      });\n      \n    }catch(err){\n      resolve({\n        ERROR: true, \n        err: err.toString()\n      });\n    }\n    \n  })\n\n  \n})()",
    "key": "786f3c96-22fb-4904-8fd8-9feba20c7fc5"
  }
}